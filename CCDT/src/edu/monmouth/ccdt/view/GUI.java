package edu.monmouth.ccdt.view;

import java.util.ArrayList;
import java.util.Vector;

import javax.swing.AbstractListModel;
import javax.swing.JFileChooser;
import javax.swing.ListSelectionModel;
import javax.swing.event.ListSelectionEvent;
import javax.swing.event.ListSelectionListener;
import javax.swing.event.TreeModelListener;
import javax.swing.event.TreeSelectionEvent;
import javax.swing.event.TreeSelectionListener;
import javax.swing.text.html.HTMLEditorKit;
import javax.swing.text.html.StyleSheet;
import javax.swing.tree.TreeModel;
import javax.swing.tree.TreePath;
import javax.swing.tree.TreeSelectionModel;

import edu.monmouth.ccdt.controller.Controller;
import edu.monmouth.ccdt.data.ChangeType;
import edu.monmouth.ccdt.data.File;
import edu.monmouth.ccdt.data.Line;
import edu.monmouth.ccdt.data.Program;
import edu.monmouth.ccdt.data.Version;

public class GUI extends javax.swing.JFrame implements View {

	private static final long serialVersionUID = -7471359688824283973L;
	private Program program;
	private Controller controller;
	
	
	@Override
	public void loadProgram(Program program) {
		// TODO Auto-generated method stub
		this.program = program;

		listVersions.setModel(new VersionListModel());
		listVersions.setSelectedIndex(0);
		
		if (this.program.getVersions().size() > 0){
			treeFiles.setModel(new VersionTreeModel(this.program.getVersions().get(0)));
		}
		else{
			treeFiles.setModel(null);
		}
	}

	private void exit(){
		this.dispose();
	}

	private void openVersion(){
		JFileChooser chooser = new JFileChooser();
		chooser.setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY);

		int returnVal = chooser.showOpenDialog(this);
		if(returnVal == JFileChooser.APPROVE_OPTION) {
			this.controller.addVersion(chooser.getSelectedFile());
		}
	}
	public GUI(Controller controller) {
		initComponents();
		
		this.controller = controller;
		
		listVersions.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
		
		treeFiles.getSelectionModel().setSelectionMode
        (TreeSelectionModel.SINGLE_TREE_SELECTION);
		
		listVersions.addListSelectionListener(new ListSelectionListener() {
			
			@Override
			public void valueChanged(ListSelectionEvent arg0) {
				int selectedIndex = listVersions.getSelectedIndex();
				if (selectedIndex >= 0){
					treeFiles.setModel(new VersionTreeModel(GUI.this.program.getVersions().get(selectedIndex)));
				}
				
			}
		});
		
		treeFiles.addTreeSelectionListener(new TreeSelectionListener() {
			
			@Override
			public void valueChanged(TreeSelectionEvent arg0) {
				GUI.VersionTreeModel.TreeNode treeNode = (GUI.VersionTreeModel.TreeNode)treeFiles.getLastSelectedPathComponent();
				
				if (treeNode != null){
					int previousVersionIndex = GUI.this.listVersions.getSelectedIndex() - 1;
					if (previousVersionIndex >= 0){
						textPanePreviousVersion.setText(loadFileIntoHTML(treeNode.getFile().getSameFileFromVersion(GUI.this.program.getVersions().get(previousVersionIndex))));
					}else{
						textPanePreviousVersion.setText("");
						
					}
					
					textPaneCurrentVersion.setText(loadFileIntoHTML(treeNode.getFile()));
				}
			}
		});
		textPaneCurrentVersion.setContentType("text/html");
		textPanePreviousVersion.setContentType("text/html");
		this.textPaneCurrentVersion.setEditable(false);
		this.textPanePreviousVersion.setEditable(false);
		
		StyleSheet ss = ((HTMLEditorKit)textPaneCurrentVersion.getEditorKit()).getStyleSheet();
		ss.addRule(".added {color:green}");
		ss.addRule(".deleted {color:red}");
		ss.addRule(".changed {color:blue}");
		HTMLEditorKit kit = (HTMLEditorKit) textPaneCurrentVersion.getEditorKit();
		kit.setStyleSheet(ss);

		textPaneCurrentVersion.setEditorKit(kit);
	}
	
	private String loadFileIntoHTML(File file){
		if (file == null){
			return "";
		}
		StringBuilder sb = new StringBuilder();
		sb.append("<html><body><table>");
		int lineNum = 1;
		for (Line line : file.getLines()){
			String classString = "";
			if (line.getType() == ChangeType.ADDED){
				classString = "added";
			}else if (line.getType() == ChangeType.DELETED){
				classString = "deleted";
			}else if (line.getType() == ChangeType.CHANGED){
				classString = "changed";
			}
			
			sb.append("<tr><td><span>" + lineNum + "</span></td><td class=\"" + classString + "\">").append(line.getLine()).append("</td></tr>");
			lineNum++;
		}
		sb.append("</table></body></html>");
		

		return sb.toString();
	}
	/**
	 * This method is called from within the constructor to initialize the form.
	 * WARNING: Do NOT modify this code. The content of this method is always
	 * regenerated by the Form Editor.
	 */
	@SuppressWarnings("unchecked")
	// <editor-fold defaultstate="collapsed" desc="Generated Code">                          
	private void initComponents() {

		jScrollPane1 = new javax.swing.JScrollPane();
		textPanePreviousVersion = new javax.swing.JTextPane();
		jScrollPane2 = new javax.swing.JScrollPane();
		textPaneCurrentVersion = new javax.swing.JTextPane();
		jScrollPane3 = new javax.swing.JScrollPane();
		treeFiles = new javax.swing.JTree();
		jScrollPane4 = new javax.swing.JScrollPane();
		listVersions = new javax.swing.JList();
		labelCurrentVersion = new javax.swing.JLabel();
		labelPreviousVersion1 = new javax.swing.JLabel();
		jMenuBar1 = new javax.swing.JMenuBar();
		menuFile = new javax.swing.JMenu();
		jMenuItem1 = new javax.swing.JMenuItem();
		jMenuItem2 = new javax.swing.JMenuItem();

		setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
		setTitle("Change Counter Development Tool");
		setResizable(false);

		jScrollPane1.setViewportView(textPanePreviousVersion);

		jScrollPane2.setViewportView(textPaneCurrentVersion);

		jScrollPane3.setViewportView(treeFiles);

		jScrollPane4.setViewportView(listVersions);

		labelCurrentVersion.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
		labelCurrentVersion.setText("Current Version");

		labelPreviousVersion1.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
		labelPreviousVersion1.setText("Previous Version");

		menuFile.setText("File");

		jMenuItem1.setText("Open Version Folder");
		jMenuItem1.addActionListener(new java.awt.event.ActionListener() {
			public void actionPerformed(java.awt.event.ActionEvent evt) {
				openVersion();
			}
		});
		menuFile.add(jMenuItem1);

		jMenuItem2.setText("Exit");
		menuFile.add(jMenuItem2);

		jMenuBar1.add(menuFile);

		setJMenuBar(jMenuBar1);

		javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
		getContentPane().setLayout(layout);
		layout.setHorizontalGroup(
				layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
				.addGroup(layout.createSequentialGroup()
						.addContainerGap()
						.addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
								.addComponent(jScrollPane3, javax.swing.GroupLayout.DEFAULT_SIZE, 158, Short.MAX_VALUE)
								.addComponent(jScrollPane4))
								.addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
								.addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
										.addGroup(layout.createSequentialGroup()
												.addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 326, javax.swing.GroupLayout.PREFERRED_SIZE)
												.addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
												.addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, 326, javax.swing.GroupLayout.PREFERRED_SIZE))
												.addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
														.addComponent(labelPreviousVersion1, javax.swing.GroupLayout.DEFAULT_SIZE, 325, Short.MAX_VALUE)
														.addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
														.addComponent(labelCurrentVersion, javax.swing.GroupLayout.PREFERRED_SIZE, 326, javax.swing.GroupLayout.PREFERRED_SIZE)))
														.addContainerGap())
				);
		layout.setVerticalGroup(
				layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
				.addGroup(layout.createSequentialGroup()
						.addContainerGap()
						.addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
								.addGroup(layout.createSequentialGroup()
										.addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
												.addComponent(labelCurrentVersion, javax.swing.GroupLayout.PREFERRED_SIZE, 26, javax.swing.GroupLayout.PREFERRED_SIZE)
												.addComponent(labelPreviousVersion1, javax.swing.GroupLayout.PREFERRED_SIZE, 26, javax.swing.GroupLayout.PREFERRED_SIZE))
												.addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
												.addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
														.addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 437, javax.swing.GroupLayout.PREFERRED_SIZE)
														.addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, 437, javax.swing.GroupLayout.PREFERRED_SIZE)))
														.addGroup(layout.createSequentialGroup()
																.addComponent(jScrollPane3, javax.swing.GroupLayout.PREFERRED_SIZE, 138, javax.swing.GroupLayout.PREFERRED_SIZE)
																.addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
																.addComponent(jScrollPane4, javax.swing.GroupLayout.PREFERRED_SIZE, 330, javax.swing.GroupLayout.PREFERRED_SIZE)))
																.addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
				);

		pack();
	}// </editor-fold>                        

                                   
	// Variables declaration - do not modify                     
	private javax.swing.JMenuBar jMenuBar1;
	private javax.swing.JMenuItem jMenuItem1;
	private javax.swing.JMenuItem jMenuItem2;
	private javax.swing.JScrollPane jScrollPane1;
	private javax.swing.JScrollPane jScrollPane2;
	private javax.swing.JScrollPane jScrollPane3;
	private javax.swing.JScrollPane jScrollPane4;
	private javax.swing.JLabel labelCurrentVersion;
	private javax.swing.JLabel labelPreviousVersion1;
	private javax.swing.JList listVersions;
	private javax.swing.JMenu menuFile;
	private javax.swing.JTextPane textPaneCurrentVersion;
	private javax.swing.JTextPane textPanePreviousVersion;
	private javax.swing.JTree treeFiles;
	// End of variables declaration      

	private class VersionListModel extends AbstractListModel{

		@Override
		public String getElementAt(int index) {
			return program.getVersions().get(index).getName();

		}

		@Override
		public int getSize() {
			// TODO Auto-generated method stub
			return program.getVersions().size();
		}

	}
	private class VersionTreeModel implements TreeModel{

		private Version version;
		private TreeNode root;
		private Vector<TreeModelListener> listeners = new Vector<TreeModelListener>();

		public VersionTreeModel(Version version) {
			this.version = version;
			root = new TreeNode(null, "/");
			
			int parentDirectoryCount = version.getDirectory().getPath().split("[\\\\/]").length;

			for (int fileI = 0; fileI < version.getFiles().size(); fileI++){
				File file = version.getFiles().get(fileI);
				String[] filePathArray = file.getFilePath().split("[\\\\/]");
				
				TreeNode currentDirectory = root;
				
	 FilePath: for (int i = parentDirectoryCount; i < filePathArray.length; i++){
		 			String filePathPart = filePathArray[i];
					
					for (TreeNode treeNode : currentDirectory.children){
						if (treeNode.toString().equals(filePathPart)){
							currentDirectory = treeNode;
							break FilePath;
						}
					}
	
					TreeNode treeNode;
					if (i == filePathArray.length-1)	
						treeNode = new TreeNode(file, filePathPart);
					else
						treeNode = new TreeNode(null, filePathPart);
					
					currentDirectory.children.add(treeNode);
					currentDirectory = treeNode;
				}
			}
		}

		public Object getRoot() {
			return root;
		}

		public Object getChild(Object parent, int index) {
			TreeNode treeNode = (TreeNode) parent;
			return treeNode.children.get(index);
		}

		public int getChildCount(Object parent) {
			TreeNode treeNode = (TreeNode) parent;
			return treeNode.children.size();
		}

		public boolean isLeaf(Object node) {
			TreeNode treeNode = (TreeNode) node;
			return treeNode.children.size() == 0;
		}

		public int getIndexOfChild(Object parent, Object child) {
			TreeNode parentNode = (TreeNode) parent;
			TreeNode childNode = (TreeNode) child;
			return parentNode.children.indexOf(childNode);
		}

		public void valueForPathChanged(TreePath path, Object value) {
		}

		private void fireTreeNodesChanged(TreePath parentPath, int[] indices, Object[] children) {
		}

		public void addTreeModelListener(TreeModelListener listener) {
			listeners.add(listener);
		}

		public void removeTreeModelListener(TreeModelListener listener) {
			listeners.remove(listener);
		}

		public class TreeNode{
			ArrayList<TreeNode> children = new ArrayList<TreeNode>();
			File file;
			String title;
			public TreeNode(File file, String title) {
				this.file = file;
				this.title = title;
			}
			
			@Override
			public String toString() {
				if (title != null)
					return title;
				else{
					return file.getFileName();
				}
			}
			
			public File getFile(){
				return file;
			}
		}
	}
}