package edu.monmouth.ccdt.view;

import java.io.File;
import java.util.Iterator;
import java.util.Vector;

import javax.swing.AbstractListModel;
import javax.swing.JFileChooser;
import javax.swing.ListModel;
import javax.swing.ListSelectionModel;
import javax.swing.event.ListSelectionEvent;
import javax.swing.event.ListSelectionListener;
import javax.swing.event.TreeModelEvent;
import javax.swing.event.TreeModelListener;
import javax.swing.tree.TreeModel;
import javax.swing.tree.TreePath;

import edu.monmouth.ccdt.controller.Controller;
import edu.monmouth.ccdt.data.Program;

public class GUI extends javax.swing.JFrame implements View {

	private static final long serialVersionUID = -7471359688824283973L;
	private Program program;
	private Controller controller;
	
	
	@Override
	public void loadProgram(Program program) {
		// TODO Auto-generated method stub
		this.program = program;

		listVersions.setModel((ListModel) new VersionListModel());
		listVersions.setSelectedIndex(0);
		
		if (this.program.getVersions().size() > 0){
			treeFiles.setModel(new VersionTreeModel(this.program.getVersions().get(0).getDirectory()));
		}
		else{
			treeFiles.setModel(null);
		}
	}

	private void exit(){
		this.dispose();
	}

	private void openVersion(){
		JFileChooser chooser = new JFileChooser();
		chooser.setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY);

		int returnVal = chooser.showOpenDialog(this);
		if(returnVal == JFileChooser.APPROVE_OPTION) {
			this.controller.addVersion(chooser.getSelectedFile());
		}
	}
	public GUI(Controller controller) {
		initComponents();
		
		this.controller = controller;
		
		listVersions.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
		
		listVersions.addListSelectionListener(new ListSelectionListener() {
			
			@Override
			public void valueChanged(ListSelectionEvent arg0) {
				int selectedIndex = listVersions.getSelectedIndex();
				if (selectedIndex >= 0){
					treeFiles.setModel(new VersionTreeModel(GUI.this.program.getVersions().get(selectedIndex).getDirectory()));
				}
				
			}
		});
	}

	/**
	 * This method is called from within the constructor to initialize the form.
	 * WARNING: Do NOT modify this code. The content of this method is always
	 * regenerated by the Form Editor.
	 */
	@SuppressWarnings("unchecked")
	// <editor-fold defaultstate="collapsed" desc="Generated Code">                          
	private void initComponents() {

		jScrollPane1 = new javax.swing.JScrollPane();
		textPanePreviousVersion = new javax.swing.JTextPane();
		jScrollPane2 = new javax.swing.JScrollPane();
		textPaneCurrentVersion = new javax.swing.JTextPane();
		jScrollPane3 = new javax.swing.JScrollPane();
		treeFiles = new javax.swing.JTree();
		jScrollPane4 = new javax.swing.JScrollPane();
		listVersions = new javax.swing.JList();
		labelCurrentVersion = new javax.swing.JLabel();
		labelPreviousVersion1 = new javax.swing.JLabel();
		jMenuBar1 = new javax.swing.JMenuBar();
		menuFile = new javax.swing.JMenu();
		jMenuItem1 = new javax.swing.JMenuItem();
		jMenuItem2 = new javax.swing.JMenuItem();

		setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
		setTitle("Change Counter Development Tool");
		setResizable(false);

		jScrollPane1.setViewportView(textPanePreviousVersion);

		jScrollPane2.setViewportView(textPaneCurrentVersion);

		jScrollPane3.setViewportView(treeFiles);

		jScrollPane4.setViewportView(listVersions);

		labelCurrentVersion.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
		labelCurrentVersion.setText("Current Version");

		labelPreviousVersion1.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
		labelPreviousVersion1.setText("Previous Version");

		menuFile.setText("File");

		jMenuItem1.setText("Open Version Folder");
		jMenuItem1.addActionListener(new java.awt.event.ActionListener() {
			public void actionPerformed(java.awt.event.ActionEvent evt) {
				openVersion();
			}
		});
		menuFile.add(jMenuItem1);

		jMenuItem2.setText("Exit");
		menuFile.add(jMenuItem2);

		jMenuBar1.add(menuFile);

		setJMenuBar(jMenuBar1);

		javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
		getContentPane().setLayout(layout);
		layout.setHorizontalGroup(
				layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
				.addGroup(layout.createSequentialGroup()
						.addContainerGap()
						.addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
								.addComponent(jScrollPane3, javax.swing.GroupLayout.DEFAULT_SIZE, 158, Short.MAX_VALUE)
								.addComponent(jScrollPane4))
								.addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
								.addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
										.addGroup(layout.createSequentialGroup()
												.addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 326, javax.swing.GroupLayout.PREFERRED_SIZE)
												.addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
												.addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, 326, javax.swing.GroupLayout.PREFERRED_SIZE))
												.addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
														.addComponent(labelPreviousVersion1, javax.swing.GroupLayout.DEFAULT_SIZE, 325, Short.MAX_VALUE)
														.addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
														.addComponent(labelCurrentVersion, javax.swing.GroupLayout.PREFERRED_SIZE, 326, javax.swing.GroupLayout.PREFERRED_SIZE)))
														.addContainerGap())
				);
		layout.setVerticalGroup(
				layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
				.addGroup(layout.createSequentialGroup()
						.addContainerGap()
						.addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
								.addGroup(layout.createSequentialGroup()
										.addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
												.addComponent(labelCurrentVersion, javax.swing.GroupLayout.PREFERRED_SIZE, 26, javax.swing.GroupLayout.PREFERRED_SIZE)
												.addComponent(labelPreviousVersion1, javax.swing.GroupLayout.PREFERRED_SIZE, 26, javax.swing.GroupLayout.PREFERRED_SIZE))
												.addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
												.addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
														.addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 437, javax.swing.GroupLayout.PREFERRED_SIZE)
														.addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, 437, javax.swing.GroupLayout.PREFERRED_SIZE)))
														.addGroup(layout.createSequentialGroup()
																.addComponent(jScrollPane3, javax.swing.GroupLayout.PREFERRED_SIZE, 138, javax.swing.GroupLayout.PREFERRED_SIZE)
																.addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
																.addComponent(jScrollPane4, javax.swing.GroupLayout.PREFERRED_SIZE, 330, javax.swing.GroupLayout.PREFERRED_SIZE)))
																.addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
				);

		pack();
	}// </editor-fold>                        

                                   
	// Variables declaration - do not modify                     
	private javax.swing.JMenuBar jMenuBar1;
	private javax.swing.JMenuItem jMenuItem1;
	private javax.swing.JMenuItem jMenuItem2;
	private javax.swing.JScrollPane jScrollPane1;
	private javax.swing.JScrollPane jScrollPane2;
	private javax.swing.JScrollPane jScrollPane3;
	private javax.swing.JScrollPane jScrollPane4;
	private javax.swing.JLabel labelCurrentVersion;
	private javax.swing.JLabel labelPreviousVersion1;
	private javax.swing.JList listVersions;
	private javax.swing.JMenu menuFile;
	private javax.swing.JTextPane textPaneCurrentVersion;
	private javax.swing.JTextPane textPanePreviousVersion;
	private javax.swing.JTree treeFiles;
	// End of variables declaration      

	private class VersionListModel extends AbstractListModel{

		@Override
		public String getElementAt(int index) {
			return program.getVersions().get(index).getName();
		}

		@Override
		public int getSize() {
			// TODO Auto-generated method stub
			return program.getVersions().size();
		}

	}
	private class VersionTreeModel implements TreeModel{

		private File root;

		private Vector<TreeModelListener> listeners = new Vector<TreeModelListener>();

		public VersionTreeModel(File rootDirectory) {
			root = rootDirectory;
		}

		public Object getRoot() {
			return root;
		}

		public Object getChild(Object parent, int index) {
			File directory = (File) parent;
			String[] children = directory.list();
			return new TreeFile(directory, children[index]);
		}

		public int getChildCount(Object parent) {
			File file = (File) parent;
			if (file.isDirectory()) {
				String[] fileList = file.list();
				if (fileList != null)
					return file.list().length;
			}
			return 0;
		}

		public boolean isLeaf(Object node) {
			File file = (File) node;
			return file.isFile();
		}

		public int getIndexOfChild(Object parent, Object child) {
			File directory = (File) parent;
			File file = (File) child;
			String[] children = directory.list();
			for (int i = 0; i < children.length; i++) {
				if (file.getName().equals(children[i])) {
					return i;
				}
			}
			return -1;

		}

		public void valueForPathChanged(TreePath path, Object value) {
			File oldFile = (File) path.getLastPathComponent();
			String fileParentPath = oldFile.getParent();
			String newFileName = (String) value;
			File targetFile = new File(fileParentPath, newFileName);
			oldFile.renameTo(targetFile);
			File parent = new File(fileParentPath);
			int[] changedChildrenIndices = { getIndexOfChild(parent, targetFile) };
			Object[] changedChildren = { targetFile };
			fireTreeNodesChanged(path.getParentPath(), changedChildrenIndices, changedChildren);

		}

		private void fireTreeNodesChanged(TreePath parentPath, int[] indices, Object[] children) {
			TreeModelEvent event = new TreeModelEvent(this, parentPath, indices, children);
			Iterator iterator = listeners.iterator();
			TreeModelListener listener = null;
			while (iterator.hasNext()) {
				listener = (TreeModelListener) iterator.next();
				listener.treeNodesChanged(event);
			}
		}

		public void addTreeModelListener(TreeModelListener listener) {
			listeners.add(listener);
		}

		public void removeTreeModelListener(TreeModelListener listener) {
			listeners.remove(listener);
		}

		private class TreeFile extends File {
			private static final long serialVersionUID = 8767823851459164053L;

			public TreeFile(File parent, String child) {
				super(parent, child);
			}

			public String toString() {
				return getName();
			}

		}
	}
}